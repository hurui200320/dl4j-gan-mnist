package info.skyblond.dl4j.gan.mnist

import org.deeplearning4j.core.storage.StatsStorage
import org.deeplearning4j.datasets.fetchers.MnistDataFetcher
import org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator
import org.deeplearning4j.nn.graph.ComputationGraph
import org.deeplearning4j.ui.model.stats.StatsListener
import org.deeplearning4j.ui.model.storage.FileStatsStorage
import org.nd4j.linalg.api.ndarray.INDArray
import org.nd4j.linalg.api.rng.distribution.BaseDistribution
import org.nd4j.linalg.dataset.MultiDataSet
import org.nd4j.linalg.factory.Nd4j
import org.slf4j.LoggerFactory
import java.awt.image.BufferedImage
import java.io.File
import javax.imageio.ImageIO

/**
 * GAN训练类。每个实体对应一种模型参数
 * labelAmplifier Typical: >= 5, <= 10
 * When too small, D won't use this label and G cannot learn category info(i.e. identify digits)
 * When too big it will cover the random noise
 * trainDTime: train d this time while train g 1 time
 * */
class GANTrainer(private val labelAmplifier: Double, private val trainDTime: Int) {
    private val labeledName = "[Amp$labelAmplifier,D$trainDTime,${System.currentTimeMillis()}]"
    private val logger = LoggerFactory.getLogger("GANTrainerAmp${labelAmplifier}D$trainDTime")
    private val workDir = File("./trainingProcess/$labeledName").prepareFolder()
    private val checkpointSaveDir = File(workDir, "checkpoint").prepareFolder()
    private val sampledPictureDir = File(workDir, "sampledPic").prepareFolder()

    /**
     * Setup model configuration first before call this method
     * @see GANConfiguration
     * */
    fun train(
        batchSize: Int, iterations: Int, seed: Long,
        noiseDistribution: BaseDistribution, ganConfiguration: GANConfiguration
    ) {
        logger.info("Start training...")
        val model = ComputationGraph(ganConfiguration.computationGraphConfiguration)
        val rawMnistDataSet = MnistDataSetIterator(
            batchSize,
            MnistDataFetcher.NUM_EXAMPLES + MnistDataFetcher.NUM_EXAMPLES_TEST,
            true,
            true,
            true,
            seed
        )

        model.init()
//        logger.info("Model summary:" + model.summary())

        val statsStorage: StatsStorage = FileStatsStorage(File(workDir, "statusStorage.dl4j.bin"))
        model.setListeners(
//            ScoreIterationListener(100),
            StatsListener(statsStorage)
        )

        // When training D, pic inputs stack on top of fake pic(G output)
        // so first batchSize is 1(i.e. real pic), then followed by batchSize 0(i.e. fake pic)
        val labelD = Nd4j.vstack(Nd4j.ones(batchSize, 1), Nd4j.zeros(batchSize, 1))
        // When training G, only later batchSize samples(generated by G) could effect G's parameters
        // To train the G, we have to falsely label them as real (1)
        // since we want G generate pic like the real one
        val labelG = Nd4j.ones(2 * batchSize, 1)

        // training loop
        for (i in 1..iterations) {
            if (!rawMnistDataSet.hasNext()) {
                rawMnistDataSet.reset()
            }
            val dataset = rawMnistDataSet.next()
            val rawPic: INDArray = dataset.features
            val rawLabel: INDArray = dataset.labels.mul(labelAmplifier)
            var noise = Nd4j.rand(
                noiseDistribution,
                batchSize.toLong(),
                ganConfiguration.noiseDimension.toLong()
            )

            val dataSetD = MultiDataSet(arrayOf(noise, rawPic, rawLabel), arrayOf(labelD))

            for (m in 1..trainDTime) {
                // train D
                // first freeze G by setting learning rate to 0
                GANConfiguration.generatorLayersName.forEach {
                    model.setLearningRate(it, 0.0)
                }
                // then make sure D have a learning rate
                GANConfiguration.discriminatorLayersName.forEach {
                    model.setLearningRate(it, ganConfiguration.learningRate)
                }
                // finally fit the model
                model.fit(dataSetD)
            }

            noise = Nd4j.rand(
                noiseDistribution,
                batchSize.toLong(),
                ganConfiguration.noiseDimension.toLong()
            )
            val dataSetG = MultiDataSet(arrayOf(noise, rawPic, rawLabel), arrayOf(labelG))

            // train G
            // first freeze D by setting learning rate to 0
            GANConfiguration.discriminatorLayersName.forEach {
                model.setLearningRate(it, 0.0)
            }
            // then make sure G have a learning rate
            GANConfiguration.generatorLayersName.forEach {
                model.setLearningRate(it, ganConfiguration.learningRate)
            }
            // finally fit the model
            model.fit(dataSetG)

            if (i % 50 == 0) {
                logger.info("Sampling number picture at iter.$i")
                // for infer, real pic are all zeros
                val inferPic = Nd4j.zeros(10, GANConfiguration.picWidth * GANConfiguration.picHeight)
                val inferNoise = Nd4j.rand(
                    noiseDistribution,
                    10L,
                    ganConfiguration.noiseDimension.toLong()
                )
                val inferLabel: INDArray = Nd4j.zeros(10, 10)
                for (index in 0..9) {
                    // set label from 0 to 9, we want get each number's picture
                    inferLabel.putScalar(intArrayOf(index, index), 1.0)
                }
                val map: Map<String, INDArray> = model.feedForward(
                    arrayOf(inferNoise, inferPic, inferLabel.mul(labelAmplifier)), false
                )
                val generatorOutput = map[GANConfiguration.generatorOutputLayerName]
                    ?: error("No layer named ${GANConfiguration.generatorOutputLayerName}")

                val bufferedImage = BufferedImage(5 * 28, 2 * 28, BufferedImage.TYPE_BYTE_GRAY)
                for (j in 0..9) {
                    // process each digits
                    val digitINDArray = generatorOutput.getRow(j.toLong())
                    // 0 1 2 3 4
                    // 5 6 7 8 9
                    for (index in 0..783) {
                        bufferedImage.raster.setSample(
                            (j % 5) * 28 + index % 28,
                            (j / 5) * 28 + index / 28,
                            0,          // channel
                            255 * digitINDArray.getDouble(index.toLong())
                        )
                    }
                }
                ImageIO.write(
                    bufferedImage,
                    "png",
                    File(sampledPictureDir, "iter${i}.png")
                )
            }

//            if (i % 2000 == 0) {
//                logger.info("Checkpoint hit!")
//                model.save(
//                    File(
//                        checkpointSaveDir,
//                        "checkpoint_$i.zip"
//                    ), true
//                )
//            }
        }

        model.save(
            File(workDir, "ModelSave.zip"),
            true
        )
        logger.info("Done! Model saved.")
    }
}