package info.skyblond.dl4j.gan.mnist

import org.deeplearning4j.core.storage.StatsStorage
import org.deeplearning4j.datasets.fetchers.MnistDataFetcher
import org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator
import org.deeplearning4j.ui.VertxUIServer
import org.deeplearning4j.ui.model.stats.StatsListener
import org.deeplearning4j.ui.model.storage.FileStatsStorage
import org.nd4j.linalg.api.ndarray.INDArray
import org.nd4j.linalg.api.rng.distribution.impl.UniformDistribution
import org.nd4j.linalg.dataset.MultiDataSet
import org.nd4j.linalg.factory.Nd4j
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.charset.StandardCharsets
import javax.imageio.ImageIO
import kotlin.random.Random

// Global parameter
const val noiseDim = 100
const val labelDim = 10
const val picHeight = 28
const val picWidth = 28
val noiseDistribution = UniformDistribution(0.0, 1.0)

fun main() {
    val logger = LoggerFactory.getLogger("Application")

    val hyperParameter = HyperParameter(
        labelAmp = 3.0,
        learningRate = 0.0001,
        adamBeta1 = 0.5,
        seed = System.currentTimeMillis() // 1189998819991197253L
    )

    // fixed parameter
    val sampleInterval = 100
    val batchSize = 32
    val iterations = 100_0000

    val cgan = getModel(hyperParameter)

    val workingFolder = File("./trainingProcess").prepareFolder(true)
    File(workingFolder, "info.json").clear().writeText(toBeautifiedJson(hyperParameter), StandardCharsets.UTF_8)

    val ganStatsStorage: StatsStorage = FileStatsStorage(File(workingFolder, "gan.stats").clear())
    val ganStatsListener = StatsListener(ganStatsStorage)
    ganStatsListener.sessionID = "GAN"

    val discriminatorStatsStorage: StatsStorage = FileStatsStorage(File(workingFolder, "discriminator.stats").clear())
    val discriminatorStatsListener = StatsListener(discriminatorStatsStorage)
    discriminatorStatsListener.sessionID = "Discriminator"

    val uiServer = VertxUIServer.getInstance(Random.nextInt(20000, 40000), true, null)//) { statsStorageProvider[it] }
    uiServer.attach(ganStatsStorage)
    uiServer.attach(discriminatorStatsStorage)

    cgan.gan.setListeners(ganStatsListener)
    cgan.discriminator.setListeners(discriminatorStatsListener)

    val trainMnistDataSet = MnistDataSetIterator(
        batchSize,
        MnistDataFetcher.NUM_EXAMPLES,
        true, true, true, hyperParameter.seed
    )


    val testMnistDataSet = MnistDataSetIterator(
        batchSize,
        MnistDataFetcher.NUM_EXAMPLES_TEST,
        true, true, true, hyperParameter.seed
    )

    // training loop
    for (i in 0 until iterations) {
        cgan.updateParameters()

        if (!trainMnistDataSet.hasNext()) {
            trainMnistDataSet.reset()
        }

        // sample real pic
        val dataset = trainMnistDataSet.next()
        val realPic: INDArray = dataset.features
        var label: INDArray = dataset.labels.mul(hyperParameter.labelAmp)

        var noise = Nd4j.rand(noiseDistribution, label.shape()[0], noiseDim.toLong())

        // sample G
        val fakePic = cgan.generator.feedForward(arrayOf(noise, label), false)[CGAN.GENERATOR_OUTPUT_NAME]
            ?: error("No layer named ${CGAN.GENERATOR_OUTPUT_NAME}")

        // make up the dataset for D
        val featurePicD = Nd4j.vstack(realPic, fakePic)
        val featureLabelD = Nd4j.vstack(label, label)

        // When training D, real pic inputs stack on top of fake pic(G output)
        // so first batchSize is 1(i.e. real pic), then followed by batchSize 0(i.e. fake pic)
        val labelD = Nd4j.vstack(Nd4j.ones(realPic.shape()[0], 1), Nd4j.zeros(fakePic.shape()[0], 1))

        val dataSetD = MultiDataSet(arrayOf(featurePicD, featureLabelD), arrayOf(labelD))

        cgan.discriminator.fit(dataSetD)

        cgan.updateParameters()

        // When training G, only later batchSize samples(generated by G) could effect G's parameters
        // To train the G, we have to falsely label them as real (1)
        // since we want G generate pic like the real one
        val labelG = Nd4j.ones(batchSize, 1)

        // train G
        // sample random dataset
        noise = Nd4j.rand(noiseDistribution, batchSize.toLong(), noiseDim.toLong())
        label = Nd4j.zeros(batchSize.toLong(), labelDim.toLong())
        for (index in 0 until batchSize) {
            val randomLabel = Random.nextInt(0, 10)
            label.putScalar(intArrayOf(index, randomLabel), hyperParameter.labelAmp)
        }
        val dataSetG = MultiDataSet(arrayOf(noise, label), arrayOf(labelG))

        cgan.gan.fit(dataSetG)

        if (i % sampleInterval == 0) {
            val result = evaluateCGAN(cgan, testMnistDataSet, hyperParameter)
            logger.info("Iter. $i: realPicAvg=${result.first}, fakePicAvg=${result.second}")

            if (result.first == 1.0) {
                logger.warn("Real pic score reached 1.0")
            }

            logger.info("Sampling number picture at iter.$i")
            // for infer, real pic are all zeros
            val inferNoise = Nd4j.rand(noiseDistribution, 10L, noiseDim.toLong())
            val inferLabel: INDArray = Nd4j.zeros(10, 10)
            for (index in 0..9) {
                // set label from 0 to 9, we want get each number's picture
                inferLabel.putScalar(intArrayOf(index, index), hyperParameter.labelAmp)
            }

            val generatorOutput = cgan.generator.feedForward(
                arrayOf(inferNoise, inferLabel), false
            )[CGAN.GENERATOR_OUTPUT_NAME] ?: error("No layer named ${CGAN.GENERATOR_OUTPUT_NAME}")

            val bufferedImage = ndArrayToImg(generatorOutput)
            ImageIO.write(
                bufferedImage,
                "png",
                File(workingFolder, "iter${i}.png")
            )
        }
    }

    cgan.save(File(workingFolder, "save"))

    uiServer.stop()
    logger.info("Done!")
}
